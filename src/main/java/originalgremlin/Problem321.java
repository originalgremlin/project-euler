package originalgremlin;

import java.util.Arrays;
import java.util.HashMap;
import java.util.PriorityQueue;

/**
 * Swapping Counters
 * Problem 321
 *
 * A horizontal row comprising of 2n + 1 squares has n red counters placed at one end and n blue counters at the
 * other end, being separated by a single empty square in the centre. For example, when n = 3.
 *
 * R R R _ B B B
 *
 * A counter can move from one square to the next (slide) or can jump over another counter (hop) as long as the square
 * next to that counter is unoccupied.
 *
 * Let M(n) represent the minimum number of moves/actions to completely reverse the positions of the coloured counters;
 * that is, move all the red counters to the right and all the blue counters to the left.
 *
 * It can be verified M(3) = 15, which also happens to be a triangle number.
 *
 * If we create a sequence based on the values of n for which M(n) is a triangle number then the first five terms would be:
 * 1, 3, 10, 22, and 63, and their sum would be 99.
 *
 * (The sequence of triangle numbers is generated by adding the natural numbers.
 * So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
 * 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...)
 *
 * Find the sum of the first forty terms of this sequence.
 */

public class Problem321 {
    private enum Color {
        RED, BLUE, BLANK
    }

    private static class State implements Comparable<State> {
        private final Color[] board;

        public State (Color[] colors) {
            this.board = Arrays.copyOf(colors, colors.length);
        }

        public State slideRight () {
            return move(-1);
        }

        public State hopRight () {
            return move(-2);
        }

        public State slideLeft () {
            return move(+1);
        }

        public State hopLeft () {
            return move(+2);
        }

        private State move (int movement) {
            int current = Arrays.asList(board).indexOf(Color.BLANK);
            int next = current + movement;
            if (next < 0 || next > board.length - 1) {
                return null;
            } else {
                Color[] successor = Arrays.copyOf(board, board.length);
                successor[current] = successor[next];
                successor[next] = Color.BLANK;
                return new State(successor);
            }
        }

        public State[] getSuccessors () {
            State[] successors = new State[]{ slideRight(), hopRight(), slideLeft(), hopLeft() };
            return Arrays.stream(successors).filter(s -> s != null).toArray(State[]::new);
        }

        public int difference (State that) {
            return 0;
        }

        @Override
        public boolean equals (Object that) {
            return (that instanceof State) && (Arrays.equals(this.board, ((State) that).board));
        }

        @Override
        public int hashCode () {
            return Arrays.hashCode(board);
        }

        @Override
        public int compareTo (State that) {
            return 0;
            //return this.depth - that.depth;
        }

        @Override
        public String toString () {
            return Arrays.toString(board);
        }
    }

    private static class FringeNode implements Comparable<FringeNode> {
        public State current;
        public State parent;
        public int priority;

        public FringeNode (State current, State parent, int priority) {
            this.current = current;
            this.parent = parent;
            this.priority = priority;
        }

        @Override
        public int compareTo (FringeNode that) {
            return this.current.compareTo(that.current);
        }
    }

    private final static int N = 3;
    private final static State START_STATE;
    private final static State GOAL_STATE;
    static {
        Color[] start = new Color[2 * N + 1];
        Color[] goal = new Color[2 * N + 1];
        for (int i = 0; i < 2 * N + 1; i++) {
            if (i < N) {
                start[i] = Color.RED;
                goal[i] = Color.BLUE;
            } else if (i > N) {
                start[i] = Color.BLUE;
                goal[i] = Color.RED;
            } else {
                start[i] = Color.BLANK;
                goal[i] = Color.BLANK;
            }
        }
        START_STATE = new State(start);
        GOAL_STATE = new State(goal);
    }

    // Use A* Search
    public static void main (String[] args) {
        HashMap<State, State> closed = new HashMap<>();

        PriorityQueue<FringeNode> fringe = new PriorityQueue<>();
        fringe.add(new FringeNode(START_STATE, null, 0));
        FringeNode node;

        int viewed = 0;
        int visited = 0;
        while (!fringe.isEmpty()) {
            viewed++;
            node = fringe.poll();
            if (node.current.equals(GOAL_STATE)) {
                State path = closed.get(node.parent);
                while (path != null) {
                    visited++;
                    path = closed.get(path);
                }
                System.out.println(viewed);
                System.out.println(visited);
                System.exit(0);
            } else if (!closed.containsKey(node.current)) {
                closed.put(node.current, node.parent);
                for (State successor : node.current.getSuccessors()) {
                    fringe.add(new FringeNode(successor, node.current, successor.compareTo(GOAL_STATE)));
                }
            }
        }
    }
}
