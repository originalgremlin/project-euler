package originalgremlin.from001to050;

import java.math.BigInteger;
import java.util.*;

/**
 * Distinct powers
 * Problem 29
 *
 * Consider all integer combinations of ab for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:

 2^2=4,  2^3=8,   2^4=16,  2^5=32
 3^2=9,  3^3=27,  3^4=81,  3^5=243
 4^2=16, 4^3=64,  4^4=256, 4^5=1024
 5^2=25, 5^3=125, 5^4=625, 5^5=3125

 * If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:
 *
 * 4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
 *
 * How many distinct terms are in the sequence generated by ab for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?
 */

public class Problem29 {
    private static class Divisors {
        private HashMap<Integer, Integer> divisors = new HashMap<>();

        public Divisors (int num) {
            this(num, 1);
        }

        public Divisors (int num, int exponent) {
            for (int divisor : getDivisors(num)) {
                divisors.put(divisor, divisors.containsKey(divisor) ? divisors.get(divisor) + 1 : 1);
            }
            for (int divisor : divisors.keySet()) {
                divisors.put(divisor, divisors.get(divisor) * exponent);
            }
        }

        public static ArrayList<Integer> getDivisors (int num) {
            ArrayList<Integer> divisors = new ArrayList<>();
            int i = 2;
            while (num > 1) {
                if (num % i == 0) {
                    divisors.add(i);
                    num /= i;
                } else {
                    i++;
                }
            }
            return divisors;
        }

        public boolean equals (Object other) {
            return (other instanceof Divisors) && (divisors.equals(((Divisors) other).divisors));
        }

        public int hashCode () {
            return divisors.hashCode();
        }

        public String toString () {
            return divisors.toString();
        }

        public BigInteger toBigInteger () {
            BigInteger big = BigInteger.ONE;
            for (Map.Entry<Integer, Integer> divisor : divisors.entrySet()) {
                big = big.multiply(BigInteger.valueOf(divisor.getKey()).pow(divisor.getValue()));
            }
            return big;
        }
    }

    public static void main (String[] args) {
        int N = 100;
        Set<Divisors> divisors = new HashSet<>();
        Set<BigInteger> bigs = new HashSet<>();
        for (int a = 2; a <= N; a++) {
            for (int b = 2; b <= N; b++) {
                divisors.add(new Divisors(a, b));
                bigs.add(BigInteger.valueOf(a).pow(b));
            }
        }
        System.out.println(divisors.size());
        System.out.println(bigs.size());
    }
}
